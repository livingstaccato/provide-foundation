# provide/foundation/file/lock.py
#
# SPDX-FileCopyrightText: Copyright (c) provide.io llc. All rights reserved.
# SPDX-License-Identifier: Apache-2.0

from __future__ import annotations

import os
from pathlib import Path
import socket
import threading
import time

import psutil

from provide.foundation.config.defaults import DEFAULT_FILE_LOCK_TIMEOUT
from provide.foundation.errors.resources import LockError
from provide.foundation.logger import get_logger
from provide.foundation.serialization import json_dumps, json_loads

"""File-based locking for concurrent access control.

Uses psutil for robust process validation to prevent PID recycling attacks.
Thread-safe for concurrent access within a single process.
"""

log = get_logger(__name__)
from inspect import signature as _mutmut_signature
from typing import Annotated
from typing import Callable
from typing import ClassVar


MutantDict = Annotated[dict[str, Callable], "Mutant"]


def _mutmut_trampoline(orig, mutants, call_args, call_kwargs, self_arg=None):
    """Forward call to original or mutated function, depending on the environment"""
    import os

    mutant_under_test = os.environ["MUTANT_UNDER_TEST"]
    if mutant_under_test == "fail":
        from mutmut.__main__ import MutmutProgrammaticFailException

        raise MutmutProgrammaticFailException("Failed programmatically")
    elif mutant_under_test == "stats":
        from mutmut.__main__ import record_trampoline_hit

        record_trampoline_hit(orig.__module__ + "." + orig.__name__)
        result = orig(*call_args, **call_kwargs)
        return result
    prefix = orig.__module__ + "." + orig.__name__ + "__mutmut_"
    if not mutant_under_test.startswith(prefix):
        result = orig(*call_args, **call_kwargs)
        return result
    mutant_name = mutant_under_test.rpartition(".")[-1]
    if self_arg:
        # call to a class method where self is not bound
        result = mutants[mutant_name](self_arg, *call_args, **call_kwargs)
    else:
        result = mutants[mutant_name](*call_args, **call_kwargs)
    return result


class FileLock:
    """File-based lock for concurrent access control.

    Uses exclusive file creation as the locking mechanism.
    The lock file contains the PID of the process holding the lock.

    Thread-safe: Multiple threads can safely use the same FileLock instance.
    The internal thread lock protects instance state while the file lock
    provides inter-process synchronization.

    Example:
        with FileLock("/tmp/myapp.lock"):
            # Exclusive access to resource
            do_something()

    """

    def xǁFileLockǁ__init____mutmut_orig(
        self,
        path: Path | str,
        timeout: float = DEFAULT_FILE_LOCK_TIMEOUT,
        check_interval: float = 0.1,
    ) -> None:
        """Initialize file lock.

        Args:
            path: Lock file path
            timeout: Max seconds to wait for lock
            check_interval: Seconds between lock checks

        """
        self.path = Path(path)
        self.timeout = timeout
        self.check_interval = check_interval
        self.locked = False
        self.pid = os.getpid()
        self._thread_lock = threading.RLock()  # Protect instance state from concurrent threads

    def xǁFileLockǁ__init____mutmut_1(
        self,
        path: Path | str,
        timeout: float = DEFAULT_FILE_LOCK_TIMEOUT,
        check_interval: float = 1.1,
    ) -> None:
        """Initialize file lock.

        Args:
            path: Lock file path
            timeout: Max seconds to wait for lock
            check_interval: Seconds between lock checks

        """
        self.path = Path(path)
        self.timeout = timeout
        self.check_interval = check_interval
        self.locked = False
        self.pid = os.getpid()
        self._thread_lock = threading.RLock()  # Protect instance state from concurrent threads

    def xǁFileLockǁ__init____mutmut_2(
        self,
        path: Path | str,
        timeout: float = DEFAULT_FILE_LOCK_TIMEOUT,
        check_interval: float = 0.1,
    ) -> None:
        """Initialize file lock.

        Args:
            path: Lock file path
            timeout: Max seconds to wait for lock
            check_interval: Seconds between lock checks

        """
        self.path = None
        self.timeout = timeout
        self.check_interval = check_interval
        self.locked = False
        self.pid = os.getpid()
        self._thread_lock = threading.RLock()  # Protect instance state from concurrent threads

    def xǁFileLockǁ__init____mutmut_3(
        self,
        path: Path | str,
        timeout: float = DEFAULT_FILE_LOCK_TIMEOUT,
        check_interval: float = 0.1,
    ) -> None:
        """Initialize file lock.

        Args:
            path: Lock file path
            timeout: Max seconds to wait for lock
            check_interval: Seconds between lock checks

        """
        self.path = Path(None)
        self.timeout = timeout
        self.check_interval = check_interval
        self.locked = False
        self.pid = os.getpid()
        self._thread_lock = threading.RLock()  # Protect instance state from concurrent threads

    def xǁFileLockǁ__init____mutmut_4(
        self,
        path: Path | str,
        timeout: float = DEFAULT_FILE_LOCK_TIMEOUT,
        check_interval: float = 0.1,
    ) -> None:
        """Initialize file lock.

        Args:
            path: Lock file path
            timeout: Max seconds to wait for lock
            check_interval: Seconds between lock checks

        """
        self.path = Path(path)
        self.timeout = None
        self.check_interval = check_interval
        self.locked = False
        self.pid = os.getpid()
        self._thread_lock = threading.RLock()  # Protect instance state from concurrent threads

    def xǁFileLockǁ__init____mutmut_5(
        self,
        path: Path | str,
        timeout: float = DEFAULT_FILE_LOCK_TIMEOUT,
        check_interval: float = 0.1,
    ) -> None:
        """Initialize file lock.

        Args:
            path: Lock file path
            timeout: Max seconds to wait for lock
            check_interval: Seconds between lock checks

        """
        self.path = Path(path)
        self.timeout = timeout
        self.check_interval = None
        self.locked = False
        self.pid = os.getpid()
        self._thread_lock = threading.RLock()  # Protect instance state from concurrent threads

    def xǁFileLockǁ__init____mutmut_6(
        self,
        path: Path | str,
        timeout: float = DEFAULT_FILE_LOCK_TIMEOUT,
        check_interval: float = 0.1,
    ) -> None:
        """Initialize file lock.

        Args:
            path: Lock file path
            timeout: Max seconds to wait for lock
            check_interval: Seconds between lock checks

        """
        self.path = Path(path)
        self.timeout = timeout
        self.check_interval = check_interval
        self.locked = None
        self.pid = os.getpid()
        self._thread_lock = threading.RLock()  # Protect instance state from concurrent threads

    def xǁFileLockǁ__init____mutmut_7(
        self,
        path: Path | str,
        timeout: float = DEFAULT_FILE_LOCK_TIMEOUT,
        check_interval: float = 0.1,
    ) -> None:
        """Initialize file lock.

        Args:
            path: Lock file path
            timeout: Max seconds to wait for lock
            check_interval: Seconds between lock checks

        """
        self.path = Path(path)
        self.timeout = timeout
        self.check_interval = check_interval
        self.locked = True
        self.pid = os.getpid()
        self._thread_lock = threading.RLock()  # Protect instance state from concurrent threads

    def xǁFileLockǁ__init____mutmut_8(
        self,
        path: Path | str,
        timeout: float = DEFAULT_FILE_LOCK_TIMEOUT,
        check_interval: float = 0.1,
    ) -> None:
        """Initialize file lock.

        Args:
            path: Lock file path
            timeout: Max seconds to wait for lock
            check_interval: Seconds between lock checks

        """
        self.path = Path(path)
        self.timeout = timeout
        self.check_interval = check_interval
        self.locked = False
        self.pid = None
        self._thread_lock = threading.RLock()  # Protect instance state from concurrent threads

    def xǁFileLockǁ__init____mutmut_9(
        self,
        path: Path | str,
        timeout: float = DEFAULT_FILE_LOCK_TIMEOUT,
        check_interval: float = 0.1,
    ) -> None:
        """Initialize file lock.

        Args:
            path: Lock file path
            timeout: Max seconds to wait for lock
            check_interval: Seconds between lock checks

        """
        self.path = Path(path)
        self.timeout = timeout
        self.check_interval = check_interval
        self.locked = False
        self.pid = os.getpid()
        self._thread_lock = None  # Protect instance state from concurrent threads

    xǁFileLockǁ__init____mutmut_mutants: ClassVar[MutantDict] = {
        "xǁFileLockǁ__init____mutmut_1": xǁFileLockǁ__init____mutmut_1,
        "xǁFileLockǁ__init____mutmut_2": xǁFileLockǁ__init____mutmut_2,
        "xǁFileLockǁ__init____mutmut_3": xǁFileLockǁ__init____mutmut_3,
        "xǁFileLockǁ__init____mutmut_4": xǁFileLockǁ__init____mutmut_4,
        "xǁFileLockǁ__init____mutmut_5": xǁFileLockǁ__init____mutmut_5,
        "xǁFileLockǁ__init____mutmut_6": xǁFileLockǁ__init____mutmut_6,
        "xǁFileLockǁ__init____mutmut_7": xǁFileLockǁ__init____mutmut_7,
        "xǁFileLockǁ__init____mutmut_8": xǁFileLockǁ__init____mutmut_8,
        "xǁFileLockǁ__init____mutmut_9": xǁFileLockǁ__init____mutmut_9,
    }

    def __init__(self, *args, **kwargs):
        result = _mutmut_trampoline(
            object.__getattribute__(self, "xǁFileLockǁ__init____mutmut_orig"),
            object.__getattribute__(self, "xǁFileLockǁ__init____mutmut_mutants"),
            args,
            kwargs,
            self,
        )
        return result

    __init__.__signature__ = _mutmut_signature(xǁFileLockǁ__init____mutmut_orig)
    xǁFileLockǁ__init____mutmut_orig.__name__ = "xǁFileLockǁ__init__"

    def xǁFileLockǁacquire__mutmut_orig(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_1(self, blocking: bool = False) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_2(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout < 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_3(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 1:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_4(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError(None, code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_5(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code=None, path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_6(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=None)

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_7(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError(code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_8(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_9(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError(
                    "Timeout must be positive",
                    code="INVALID_TIMEOUT",
                )

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_10(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("XXTimeout must be positiveXX", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_11(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_12(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("TIMEOUT MUST BE POSITIVE", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_13(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="XXINVALID_TIMEOUTXX", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_14(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="invalid_timeout", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_15(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(None))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_16(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return False

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_17(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = None
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_18(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = None
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_19(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time - self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_20(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = None  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_21(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1001  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_22(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = None

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_23(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 1

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_24(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration <= max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_25(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration = 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_26(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration -= 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_27(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 2
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_28(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = None

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_29(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time > end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_30(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = None
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_31(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time + start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_32(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        None,
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_33(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code=None,
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_34(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=None,
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_35(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_36(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_37(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_38(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="XXLOCK_TIMEOUTXX",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_39(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="lock_timeout",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_40(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(None),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_41(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = None
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_42(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(None, os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_43(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), None, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_44(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, None)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_45(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_46(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_47(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(
                        str(self.path),
                        os.O_CREAT | os.O_EXCL | os.O_WRONLY,
                    )
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_48(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(None), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_49(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL & os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_50(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT & os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_51(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 421)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_52(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = None
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_53(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "XXpidXX": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_54(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "PID": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_55(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "XXhostnameXX": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_56(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "HOSTNAME": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_57(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "XXcreatedXX": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_58(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "CREATED": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_59(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = None
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_60(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(None)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_61(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = None
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_62(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["XXstart_timeXX"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_63(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["START_TIME"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_64(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(None, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_65(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, None)
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_66(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_67(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(
                            fd,
                        )
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_68(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(None).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_69(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(None)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_70(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = None
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_71(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = False
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_72(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = None
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_73(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time + start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_74(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        None,
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_75(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=None,
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_76(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=None,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_77(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=None,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_78(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=None,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_79(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_80(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_81(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_82(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_83(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_84(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "XXAcquired lockXX",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_85(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_86(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "ACQUIRED LOCK",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_87(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(None),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_88(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return False

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_89(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        break  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_90(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_91(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug(None, path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_92(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=None)
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_93(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug(path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_94(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug(
                            "Lock unavailable (non-blocking)",
                        )
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_95(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("XXLock unavailable (non-blocking)XX", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_96(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_97(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("LOCK UNAVAILABLE (NON-BLOCKING)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_98(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(None))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_99(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return True

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_100(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = None
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_101(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time + current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_102(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining < 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_103(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 1:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_104(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        return

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_105(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = None  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_106(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(None, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_107(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, None)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_108(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_109(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(
                        0.01,
                    )  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_110(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(1.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_111(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining / 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_112(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 1.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_113(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time >= 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_114(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 1:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_115(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(None)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_116(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = None
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_117(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() + start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_118(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                None,
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_119(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code=None,
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_120(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=None,
            ) from None

    def xǁFileLockǁacquire__mutmut_121(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                code="LOCK_TIMEOUT",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_122(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_123(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
            ) from None

    def xǁFileLockǁacquire__mutmut_124(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="XXLOCK_TIMEOUTXX",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_125(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="lock_timeout",
                path=str(self.path),
            ) from None

    def xǁFileLockǁacquire__mutmut_126(self, blocking: bool = True) -> bool:  # noqa: C901
        """Acquire the lock.

        Args:
            blocking: If True, wait for lock. If False, return immediately.

        Returns:
            True if lock acquired, False if not (non-blocking mode only)

        Raises:
            LockError: If timeout exceeded (blocking mode)

        """
        with self._thread_lock:
            if self.timeout <= 0:
                raise LockError("Timeout must be positive", code="INVALID_TIMEOUT", path=str(self.path))

            # If already locked by this instance, treat as re-entrant
            if self.locked:
                return True

            # Use a finite loop with hard limits to prevent any possibility of hanging
            start_time = time.time()
            end_time = start_time + self.timeout
            max_iterations = 1000  # Hard limit regardless of timeout
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                current_time = time.time()

                # Hard timeout check - exit immediately if time is up
                if current_time >= end_time:
                    elapsed = current_time - start_time
                    raise LockError(
                        f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                        code="LOCK_TIMEOUT",
                        path=str(self.path),
                    ) from None

                try:
                    # Try to create lock file exclusively
                    fd = os.open(str(self.path), os.O_CREAT | os.O_EXCL | os.O_WRONLY, 0o644)
                    try:
                        # Write lock metadata as JSON for robust validation
                        lock_info = {
                            "pid": self.pid,
                            "hostname": socket.gethostname(),
                            "created": current_time,
                        }
                        # Add process start time for PID recycling protection
                        try:
                            proc = psutil.Process(self.pid)
                            lock_info["start_time"] = proc.create_time()
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                        os.write(fd, json_dumps(lock_info).encode())
                    finally:
                        os.close(fd)

                    self.locked = True
                    elapsed = current_time - start_time
                    log.debug(
                        "Acquired lock",
                        path=str(self.path),
                        pid=self.pid,
                        iterations=iteration,
                        elapsed=elapsed,
                    )
                    return True

                except FileExistsError:
                    # Lock file exists, check if holder is still alive
                    if self._check_stale_lock():
                        continue  # Retry after removing stale lock

                    if not blocking:
                        log.debug("Lock unavailable (non-blocking)", path=str(self.path))
                        return False

                    # Calculate remaining time
                    remaining = end_time - current_time
                    if remaining <= 0:
                        # Time is up
                        break

                    # Sleep for a small fixed interval or remaining time, whichever is smaller
                    sleep_time = min(0.01, remaining * 0.5)  # Never sleep more than 10ms
                    if sleep_time > 0:
                        time.sleep(sleep_time)

            # If we exit the loop without acquiring the lock
            elapsed = time.time() - start_time
            raise LockError(
                f"Failed to acquire lock within {self.timeout}s (elapsed: {elapsed:.3f}s, iterations: {iteration})",
                code="LOCK_TIMEOUT",
                path=str(None),
            ) from None

    xǁFileLockǁacquire__mutmut_mutants: ClassVar[MutantDict] = {
        "xǁFileLockǁacquire__mutmut_1": xǁFileLockǁacquire__mutmut_1,
        "xǁFileLockǁacquire__mutmut_2": xǁFileLockǁacquire__mutmut_2,
        "xǁFileLockǁacquire__mutmut_3": xǁFileLockǁacquire__mutmut_3,
        "xǁFileLockǁacquire__mutmut_4": xǁFileLockǁacquire__mutmut_4,
        "xǁFileLockǁacquire__mutmut_5": xǁFileLockǁacquire__mutmut_5,
        "xǁFileLockǁacquire__mutmut_6": xǁFileLockǁacquire__mutmut_6,
        "xǁFileLockǁacquire__mutmut_7": xǁFileLockǁacquire__mutmut_7,
        "xǁFileLockǁacquire__mutmut_8": xǁFileLockǁacquire__mutmut_8,
        "xǁFileLockǁacquire__mutmut_9": xǁFileLockǁacquire__mutmut_9,
        "xǁFileLockǁacquire__mutmut_10": xǁFileLockǁacquire__mutmut_10,
        "xǁFileLockǁacquire__mutmut_11": xǁFileLockǁacquire__mutmut_11,
        "xǁFileLockǁacquire__mutmut_12": xǁFileLockǁacquire__mutmut_12,
        "xǁFileLockǁacquire__mutmut_13": xǁFileLockǁacquire__mutmut_13,
        "xǁFileLockǁacquire__mutmut_14": xǁFileLockǁacquire__mutmut_14,
        "xǁFileLockǁacquire__mutmut_15": xǁFileLockǁacquire__mutmut_15,
        "xǁFileLockǁacquire__mutmut_16": xǁFileLockǁacquire__mutmut_16,
        "xǁFileLockǁacquire__mutmut_17": xǁFileLockǁacquire__mutmut_17,
        "xǁFileLockǁacquire__mutmut_18": xǁFileLockǁacquire__mutmut_18,
        "xǁFileLockǁacquire__mutmut_19": xǁFileLockǁacquire__mutmut_19,
        "xǁFileLockǁacquire__mutmut_20": xǁFileLockǁacquire__mutmut_20,
        "xǁFileLockǁacquire__mutmut_21": xǁFileLockǁacquire__mutmut_21,
        "xǁFileLockǁacquire__mutmut_22": xǁFileLockǁacquire__mutmut_22,
        "xǁFileLockǁacquire__mutmut_23": xǁFileLockǁacquire__mutmut_23,
        "xǁFileLockǁacquire__mutmut_24": xǁFileLockǁacquire__mutmut_24,
        "xǁFileLockǁacquire__mutmut_25": xǁFileLockǁacquire__mutmut_25,
        "xǁFileLockǁacquire__mutmut_26": xǁFileLockǁacquire__mutmut_26,
        "xǁFileLockǁacquire__mutmut_27": xǁFileLockǁacquire__mutmut_27,
        "xǁFileLockǁacquire__mutmut_28": xǁFileLockǁacquire__mutmut_28,
        "xǁFileLockǁacquire__mutmut_29": xǁFileLockǁacquire__mutmut_29,
        "xǁFileLockǁacquire__mutmut_30": xǁFileLockǁacquire__mutmut_30,
        "xǁFileLockǁacquire__mutmut_31": xǁFileLockǁacquire__mutmut_31,
        "xǁFileLockǁacquire__mutmut_32": xǁFileLockǁacquire__mutmut_32,
        "xǁFileLockǁacquire__mutmut_33": xǁFileLockǁacquire__mutmut_33,
        "xǁFileLockǁacquire__mutmut_34": xǁFileLockǁacquire__mutmut_34,
        "xǁFileLockǁacquire__mutmut_35": xǁFileLockǁacquire__mutmut_35,
        "xǁFileLockǁacquire__mutmut_36": xǁFileLockǁacquire__mutmut_36,
        "xǁFileLockǁacquire__mutmut_37": xǁFileLockǁacquire__mutmut_37,
        "xǁFileLockǁacquire__mutmut_38": xǁFileLockǁacquire__mutmut_38,
        "xǁFileLockǁacquire__mutmut_39": xǁFileLockǁacquire__mutmut_39,
        "xǁFileLockǁacquire__mutmut_40": xǁFileLockǁacquire__mutmut_40,
        "xǁFileLockǁacquire__mutmut_41": xǁFileLockǁacquire__mutmut_41,
        "xǁFileLockǁacquire__mutmut_42": xǁFileLockǁacquire__mutmut_42,
        "xǁFileLockǁacquire__mutmut_43": xǁFileLockǁacquire__mutmut_43,
        "xǁFileLockǁacquire__mutmut_44": xǁFileLockǁacquire__mutmut_44,
        "xǁFileLockǁacquire__mutmut_45": xǁFileLockǁacquire__mutmut_45,
        "xǁFileLockǁacquire__mutmut_46": xǁFileLockǁacquire__mutmut_46,
        "xǁFileLockǁacquire__mutmut_47": xǁFileLockǁacquire__mutmut_47,
        "xǁFileLockǁacquire__mutmut_48": xǁFileLockǁacquire__mutmut_48,
        "xǁFileLockǁacquire__mutmut_49": xǁFileLockǁacquire__mutmut_49,
        "xǁFileLockǁacquire__mutmut_50": xǁFileLockǁacquire__mutmut_50,
        "xǁFileLockǁacquire__mutmut_51": xǁFileLockǁacquire__mutmut_51,
        "xǁFileLockǁacquire__mutmut_52": xǁFileLockǁacquire__mutmut_52,
        "xǁFileLockǁacquire__mutmut_53": xǁFileLockǁacquire__mutmut_53,
        "xǁFileLockǁacquire__mutmut_54": xǁFileLockǁacquire__mutmut_54,
        "xǁFileLockǁacquire__mutmut_55": xǁFileLockǁacquire__mutmut_55,
        "xǁFileLockǁacquire__mutmut_56": xǁFileLockǁacquire__mutmut_56,
        "xǁFileLockǁacquire__mutmut_57": xǁFileLockǁacquire__mutmut_57,
        "xǁFileLockǁacquire__mutmut_58": xǁFileLockǁacquire__mutmut_58,
        "xǁFileLockǁacquire__mutmut_59": xǁFileLockǁacquire__mutmut_59,
        "xǁFileLockǁacquire__mutmut_60": xǁFileLockǁacquire__mutmut_60,
        "xǁFileLockǁacquire__mutmut_61": xǁFileLockǁacquire__mutmut_61,
        "xǁFileLockǁacquire__mutmut_62": xǁFileLockǁacquire__mutmut_62,
        "xǁFileLockǁacquire__mutmut_63": xǁFileLockǁacquire__mutmut_63,
        "xǁFileLockǁacquire__mutmut_64": xǁFileLockǁacquire__mutmut_64,
        "xǁFileLockǁacquire__mutmut_65": xǁFileLockǁacquire__mutmut_65,
        "xǁFileLockǁacquire__mutmut_66": xǁFileLockǁacquire__mutmut_66,
        "xǁFileLockǁacquire__mutmut_67": xǁFileLockǁacquire__mutmut_67,
        "xǁFileLockǁacquire__mutmut_68": xǁFileLockǁacquire__mutmut_68,
        "xǁFileLockǁacquire__mutmut_69": xǁFileLockǁacquire__mutmut_69,
        "xǁFileLockǁacquire__mutmut_70": xǁFileLockǁacquire__mutmut_70,
        "xǁFileLockǁacquire__mutmut_71": xǁFileLockǁacquire__mutmut_71,
        "xǁFileLockǁacquire__mutmut_72": xǁFileLockǁacquire__mutmut_72,
        "xǁFileLockǁacquire__mutmut_73": xǁFileLockǁacquire__mutmut_73,
        "xǁFileLockǁacquire__mutmut_74": xǁFileLockǁacquire__mutmut_74,
        "xǁFileLockǁacquire__mutmut_75": xǁFileLockǁacquire__mutmut_75,
        "xǁFileLockǁacquire__mutmut_76": xǁFileLockǁacquire__mutmut_76,
        "xǁFileLockǁacquire__mutmut_77": xǁFileLockǁacquire__mutmut_77,
        "xǁFileLockǁacquire__mutmut_78": xǁFileLockǁacquire__mutmut_78,
        "xǁFileLockǁacquire__mutmut_79": xǁFileLockǁacquire__mutmut_79,
        "xǁFileLockǁacquire__mutmut_80": xǁFileLockǁacquire__mutmut_80,
        "xǁFileLockǁacquire__mutmut_81": xǁFileLockǁacquire__mutmut_81,
        "xǁFileLockǁacquire__mutmut_82": xǁFileLockǁacquire__mutmut_82,
        "xǁFileLockǁacquire__mutmut_83": xǁFileLockǁacquire__mutmut_83,
        "xǁFileLockǁacquire__mutmut_84": xǁFileLockǁacquire__mutmut_84,
        "xǁFileLockǁacquire__mutmut_85": xǁFileLockǁacquire__mutmut_85,
        "xǁFileLockǁacquire__mutmut_86": xǁFileLockǁacquire__mutmut_86,
        "xǁFileLockǁacquire__mutmut_87": xǁFileLockǁacquire__mutmut_87,
        "xǁFileLockǁacquire__mutmut_88": xǁFileLockǁacquire__mutmut_88,
        "xǁFileLockǁacquire__mutmut_89": xǁFileLockǁacquire__mutmut_89,
        "xǁFileLockǁacquire__mutmut_90": xǁFileLockǁacquire__mutmut_90,
        "xǁFileLockǁacquire__mutmut_91": xǁFileLockǁacquire__mutmut_91,
        "xǁFileLockǁacquire__mutmut_92": xǁFileLockǁacquire__mutmut_92,
        "xǁFileLockǁacquire__mutmut_93": xǁFileLockǁacquire__mutmut_93,
        "xǁFileLockǁacquire__mutmut_94": xǁFileLockǁacquire__mutmut_94,
        "xǁFileLockǁacquire__mutmut_95": xǁFileLockǁacquire__mutmut_95,
        "xǁFileLockǁacquire__mutmut_96": xǁFileLockǁacquire__mutmut_96,
        "xǁFileLockǁacquire__mutmut_97": xǁFileLockǁacquire__mutmut_97,
        "xǁFileLockǁacquire__mutmut_98": xǁFileLockǁacquire__mutmut_98,
        "xǁFileLockǁacquire__mutmut_99": xǁFileLockǁacquire__mutmut_99,
        "xǁFileLockǁacquire__mutmut_100": xǁFileLockǁacquire__mutmut_100,
        "xǁFileLockǁacquire__mutmut_101": xǁFileLockǁacquire__mutmut_101,
        "xǁFileLockǁacquire__mutmut_102": xǁFileLockǁacquire__mutmut_102,
        "xǁFileLockǁacquire__mutmut_103": xǁFileLockǁacquire__mutmut_103,
        "xǁFileLockǁacquire__mutmut_104": xǁFileLockǁacquire__mutmut_104,
        "xǁFileLockǁacquire__mutmut_105": xǁFileLockǁacquire__mutmut_105,
        "xǁFileLockǁacquire__mutmut_106": xǁFileLockǁacquire__mutmut_106,
        "xǁFileLockǁacquire__mutmut_107": xǁFileLockǁacquire__mutmut_107,
        "xǁFileLockǁacquire__mutmut_108": xǁFileLockǁacquire__mutmut_108,
        "xǁFileLockǁacquire__mutmut_109": xǁFileLockǁacquire__mutmut_109,
        "xǁFileLockǁacquire__mutmut_110": xǁFileLockǁacquire__mutmut_110,
        "xǁFileLockǁacquire__mutmut_111": xǁFileLockǁacquire__mutmut_111,
        "xǁFileLockǁacquire__mutmut_112": xǁFileLockǁacquire__mutmut_112,
        "xǁFileLockǁacquire__mutmut_113": xǁFileLockǁacquire__mutmut_113,
        "xǁFileLockǁacquire__mutmut_114": xǁFileLockǁacquire__mutmut_114,
        "xǁFileLockǁacquire__mutmut_115": xǁFileLockǁacquire__mutmut_115,
        "xǁFileLockǁacquire__mutmut_116": xǁFileLockǁacquire__mutmut_116,
        "xǁFileLockǁacquire__mutmut_117": xǁFileLockǁacquire__mutmut_117,
        "xǁFileLockǁacquire__mutmut_118": xǁFileLockǁacquire__mutmut_118,
        "xǁFileLockǁacquire__mutmut_119": xǁFileLockǁacquire__mutmut_119,
        "xǁFileLockǁacquire__mutmut_120": xǁFileLockǁacquire__mutmut_120,
        "xǁFileLockǁacquire__mutmut_121": xǁFileLockǁacquire__mutmut_121,
        "xǁFileLockǁacquire__mutmut_122": xǁFileLockǁacquire__mutmut_122,
        "xǁFileLockǁacquire__mutmut_123": xǁFileLockǁacquire__mutmut_123,
        "xǁFileLockǁacquire__mutmut_124": xǁFileLockǁacquire__mutmut_124,
        "xǁFileLockǁacquire__mutmut_125": xǁFileLockǁacquire__mutmut_125,
        "xǁFileLockǁacquire__mutmut_126": xǁFileLockǁacquire__mutmut_126,
    }

    def acquire(self, *args, **kwargs):
        result = _mutmut_trampoline(
            object.__getattribute__(self, "xǁFileLockǁacquire__mutmut_orig"),
            object.__getattribute__(self, "xǁFileLockǁacquire__mutmut_mutants"),
            args,
            kwargs,
            self,
        )
        return result

    acquire.__signature__ = _mutmut_signature(xǁFileLockǁacquire__mutmut_orig)
    xǁFileLockǁacquire__mutmut_orig.__name__ = "xǁFileLockǁacquire"

    def xǁFileLockǁrelease__mutmut_orig(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_1(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_2(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = None
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_3(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = None
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_4(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(None)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_5(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = None
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_6(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get(None)
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_7(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("XXpidXX")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_8(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("PID")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_9(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_10(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_11(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(None) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_12(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid != self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_13(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug(None, path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_14(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=None, pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_15(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=None)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_16(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug(path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_17(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_18(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug(
                                "Released lock",
                                path=str(self.path),
                            )
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_19(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("XXReleased lockXX", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_20(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_21(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("RELEASED LOCK", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_22(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(None), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_23(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                None,
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_24(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=None,
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_25(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=None,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_26(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=None,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_27(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_28(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_29(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_30(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_31(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "XXLock owned by different processXX",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_32(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_33(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "LOCK OWNED BY DIFFERENT PROCESS",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_34(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(None),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_35(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            None,
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_36(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=None,
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_37(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=None,
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_38(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_39(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_40(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_41(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "XXError checking lock ownershipXX",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_42(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_43(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "ERROR CHECKING LOCK OWNERSHIP",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_44(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(None),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_45(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(None),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_46(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error(None, path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_47(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=None, error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_48(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=None)
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_49(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error(path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_50(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_51(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error(
                    "Failed to release lock",
                    path=str(self.path),
                )
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_52(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("XXFailed to release lockXX", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_53(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_54(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("FAILED TO RELEASE LOCK", path=str(self.path), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_55(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(None), error=str(e))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_56(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(None))
            finally:
                self.locked = False

    def xǁFileLockǁrelease__mutmut_57(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = None

    def xǁFileLockǁrelease__mutmut_58(self) -> None:
        """Release the lock.

        Only removes the lock file if we own it.
        """
        with self._thread_lock:
            if not self.locked:
                return

            try:
                # Verify we own the lock before removing
                if self.path.exists():
                    try:
                        content = self.path.read_text().strip()
                        try:
                            lock_info = json_loads(content)
                            if isinstance(lock_info, dict):
                                owner_pid = lock_info.get("pid")
                            else:
                                owner_pid = lock_info if isinstance(lock_info, int) else None
                        except (ValueError, Exception):
                            owner_pid = int(content) if content.isdigit() else None

                        if owner_pid == self.pid:
                            self.path.unlink()
                            log.debug("Released lock", path=str(self.path), pid=self.pid)
                        else:
                            log.warning(
                                "Lock owned by different process",
                                path=str(self.path),
                                owner_pid=owner_pid,
                                our_pid=self.pid,
                            )
                    except Exception as e:
                        log.warning(
                            "Error checking lock ownership",
                            path=str(self.path),
                            error=str(e),
                        )
                        # Still try to remove if we think we own it
                        if self.locked:
                            self.path.unlink()
            except FileNotFoundError:
                pass  # Lock already released
            except (OSError, PermissionError) as e:
                # Failed to unlink lock file due to permission or filesystem error
                log.error("Failed to release lock", path=str(self.path), error=str(e))
            finally:
                self.locked = True

    xǁFileLockǁrelease__mutmut_mutants: ClassVar[MutantDict] = {
        "xǁFileLockǁrelease__mutmut_1": xǁFileLockǁrelease__mutmut_1,
        "xǁFileLockǁrelease__mutmut_2": xǁFileLockǁrelease__mutmut_2,
        "xǁFileLockǁrelease__mutmut_3": xǁFileLockǁrelease__mutmut_3,
        "xǁFileLockǁrelease__mutmut_4": xǁFileLockǁrelease__mutmut_4,
        "xǁFileLockǁrelease__mutmut_5": xǁFileLockǁrelease__mutmut_5,
        "xǁFileLockǁrelease__mutmut_6": xǁFileLockǁrelease__mutmut_6,
        "xǁFileLockǁrelease__mutmut_7": xǁFileLockǁrelease__mutmut_7,
        "xǁFileLockǁrelease__mutmut_8": xǁFileLockǁrelease__mutmut_8,
        "xǁFileLockǁrelease__mutmut_9": xǁFileLockǁrelease__mutmut_9,
        "xǁFileLockǁrelease__mutmut_10": xǁFileLockǁrelease__mutmut_10,
        "xǁFileLockǁrelease__mutmut_11": xǁFileLockǁrelease__mutmut_11,
        "xǁFileLockǁrelease__mutmut_12": xǁFileLockǁrelease__mutmut_12,
        "xǁFileLockǁrelease__mutmut_13": xǁFileLockǁrelease__mutmut_13,
        "xǁFileLockǁrelease__mutmut_14": xǁFileLockǁrelease__mutmut_14,
        "xǁFileLockǁrelease__mutmut_15": xǁFileLockǁrelease__mutmut_15,
        "xǁFileLockǁrelease__mutmut_16": xǁFileLockǁrelease__mutmut_16,
        "xǁFileLockǁrelease__mutmut_17": xǁFileLockǁrelease__mutmut_17,
        "xǁFileLockǁrelease__mutmut_18": xǁFileLockǁrelease__mutmut_18,
        "xǁFileLockǁrelease__mutmut_19": xǁFileLockǁrelease__mutmut_19,
        "xǁFileLockǁrelease__mutmut_20": xǁFileLockǁrelease__mutmut_20,
        "xǁFileLockǁrelease__mutmut_21": xǁFileLockǁrelease__mutmut_21,
        "xǁFileLockǁrelease__mutmut_22": xǁFileLockǁrelease__mutmut_22,
        "xǁFileLockǁrelease__mutmut_23": xǁFileLockǁrelease__mutmut_23,
        "xǁFileLockǁrelease__mutmut_24": xǁFileLockǁrelease__mutmut_24,
        "xǁFileLockǁrelease__mutmut_25": xǁFileLockǁrelease__mutmut_25,
        "xǁFileLockǁrelease__mutmut_26": xǁFileLockǁrelease__mutmut_26,
        "xǁFileLockǁrelease__mutmut_27": xǁFileLockǁrelease__mutmut_27,
        "xǁFileLockǁrelease__mutmut_28": xǁFileLockǁrelease__mutmut_28,
        "xǁFileLockǁrelease__mutmut_29": xǁFileLockǁrelease__mutmut_29,
        "xǁFileLockǁrelease__mutmut_30": xǁFileLockǁrelease__mutmut_30,
        "xǁFileLockǁrelease__mutmut_31": xǁFileLockǁrelease__mutmut_31,
        "xǁFileLockǁrelease__mutmut_32": xǁFileLockǁrelease__mutmut_32,
        "xǁFileLockǁrelease__mutmut_33": xǁFileLockǁrelease__mutmut_33,
        "xǁFileLockǁrelease__mutmut_34": xǁFileLockǁrelease__mutmut_34,
        "xǁFileLockǁrelease__mutmut_35": xǁFileLockǁrelease__mutmut_35,
        "xǁFileLockǁrelease__mutmut_36": xǁFileLockǁrelease__mutmut_36,
        "xǁFileLockǁrelease__mutmut_37": xǁFileLockǁrelease__mutmut_37,
        "xǁFileLockǁrelease__mutmut_38": xǁFileLockǁrelease__mutmut_38,
        "xǁFileLockǁrelease__mutmut_39": xǁFileLockǁrelease__mutmut_39,
        "xǁFileLockǁrelease__mutmut_40": xǁFileLockǁrelease__mutmut_40,
        "xǁFileLockǁrelease__mutmut_41": xǁFileLockǁrelease__mutmut_41,
        "xǁFileLockǁrelease__mutmut_42": xǁFileLockǁrelease__mutmut_42,
        "xǁFileLockǁrelease__mutmut_43": xǁFileLockǁrelease__mutmut_43,
        "xǁFileLockǁrelease__mutmut_44": xǁFileLockǁrelease__mutmut_44,
        "xǁFileLockǁrelease__mutmut_45": xǁFileLockǁrelease__mutmut_45,
        "xǁFileLockǁrelease__mutmut_46": xǁFileLockǁrelease__mutmut_46,
        "xǁFileLockǁrelease__mutmut_47": xǁFileLockǁrelease__mutmut_47,
        "xǁFileLockǁrelease__mutmut_48": xǁFileLockǁrelease__mutmut_48,
        "xǁFileLockǁrelease__mutmut_49": xǁFileLockǁrelease__mutmut_49,
        "xǁFileLockǁrelease__mutmut_50": xǁFileLockǁrelease__mutmut_50,
        "xǁFileLockǁrelease__mutmut_51": xǁFileLockǁrelease__mutmut_51,
        "xǁFileLockǁrelease__mutmut_52": xǁFileLockǁrelease__mutmut_52,
        "xǁFileLockǁrelease__mutmut_53": xǁFileLockǁrelease__mutmut_53,
        "xǁFileLockǁrelease__mutmut_54": xǁFileLockǁrelease__mutmut_54,
        "xǁFileLockǁrelease__mutmut_55": xǁFileLockǁrelease__mutmut_55,
        "xǁFileLockǁrelease__mutmut_56": xǁFileLockǁrelease__mutmut_56,
        "xǁFileLockǁrelease__mutmut_57": xǁFileLockǁrelease__mutmut_57,
        "xǁFileLockǁrelease__mutmut_58": xǁFileLockǁrelease__mutmut_58,
    }

    def release(self, *args, **kwargs):
        result = _mutmut_trampoline(
            object.__getattribute__(self, "xǁFileLockǁrelease__mutmut_orig"),
            object.__getattribute__(self, "xǁFileLockǁrelease__mutmut_mutants"),
            args,
            kwargs,
            self,
        )
        return result

    release.__signature__ = _mutmut_signature(xǁFileLockǁrelease__mutmut_orig)
    xǁFileLockǁrelease__mutmut_orig.__name__ = "xǁFileLockǁrelease"

    def xǁFileLockǁ_check_stale_lock__mutmut_orig(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_1(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_2(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return True

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_3(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = None
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_4(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return True

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_5(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = ""
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_6(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = ""
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_7(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = None
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_8(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(None)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_9(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = None
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_10(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get(None)
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_11(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("XXpidXX")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_12(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("PID")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_13(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = None
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_14(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get(None)
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_15(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("XXstart_timeXX")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_16(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("START_TIME")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_17(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = None
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_18(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug(None, path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_19(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=None, content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_20(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=None)
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_21(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug(path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_22(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_23(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug(
                        "Invalid lock file content",
                        path=str(self.path),
                    )
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_24(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("XXInvalid lock file contentXX", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_25(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_26(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("INVALID LOCK FILE CONTENT", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_27(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(None), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_28(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:51])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_29(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return True
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_30(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = None
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_31(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(None)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_32(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug(None, path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_33(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=None, content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_34(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=None)
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_35(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug(path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_36(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_37(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug(
                        "Invalid lock file content",
                        path=str(self.path),
                    )
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_38(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("XXInvalid lock file contentXX", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_39(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_40(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("INVALID LOCK FILE CONTENT", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_41(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(None), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_42(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:51])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_43(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return True

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_44(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is not None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_45(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug(None, path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_46(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=None)
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_47(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug(path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_48(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug(
                    "No PID in lock file",
                )
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_49(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("XXNo PID in lock fileXX", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_50(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("no pid in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_51(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("NO PID IN LOCK FILE", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_52(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(None))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_53(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return True

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_54(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = None

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_55(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(None)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_56(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = None

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_57(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None or abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_58(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_59(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(None) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_60(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time + lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_61(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) >= 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_62(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 2.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_63(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        None,
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_64(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=None,
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_65(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=None,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_66(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=None,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_67(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=None,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_68(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_69(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_70(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_71(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_72(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_73(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "XXPID recycling detected - removing stale lockXX",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_74(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "pid recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_75(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID RECYCLING DETECTED - REMOVING STALE LOCK",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_76(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(None),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_77(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return False
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_78(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return False
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_79(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return True

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_80(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return True

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_81(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning(None, path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_82(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=None, stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_83(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=None)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_84(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning(path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_85(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_86(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning(
                    "Removing stale lock - process not found",
                    path=str(self.path),
                )
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_87(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning(
                    "XXRemoving stale lock - process not foundXX", path=str(self.path), stale_pid=lock_pid
                )
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_88(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_89(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("REMOVING STALE LOCK - PROCESS NOT FOUND", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_90(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(None), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_91(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return False
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_92(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return False
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_93(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return True

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_94(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return True

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_95(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug(None, path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_96(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=None, error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_97(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=None)
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_98(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug(path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_99(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_100(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug(
                "Error checking stale lock",
                path=str(self.path),
            )
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_101(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("XXError checking stale lockXX", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_102(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("error checking stale lock", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_103(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("ERROR CHECKING STALE LOCK", path=str(self.path), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_104(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(None), error=str(e))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_105(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(None))
            return False

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_106(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return True

        return False

    def xǁFileLockǁ_check_stale_lock__mutmut_107(self) -> bool:  # noqa: C901
        """Check if lock file is stale and remove if so.

        Uses psutil to validate process start time, preventing PID recycling attacks.
        Falls back to simple PID check for backward compatibility with old lock files.

        Returns:
            True if stale lock was removed, False otherwise

        Note:
            Complexity is intentionally high to handle all security-critical cases
            (PID recycling, format compatibility, error handling).

        """
        try:
            # Quick existence check first
            if not self.path.exists():
                return False

            # Read content with a fallback to prevent hanging on I/O
            try:
                content = self.path.read_text().strip()
            except (OSError, PermissionError, UnicodeDecodeError):
                # OSError/PermissionError: Can't read file
                # UnicodeDecodeError: File has invalid encoding
                # If we can't read the file, assume it's not stale
                return False

            lock_pid = None
            lock_start_time = None
            try:
                lock_info = json_loads(content)
                if isinstance(lock_info, dict):
                    lock_pid = lock_info.get("pid")
                    lock_start_time = lock_info.get("start_time")
                elif isinstance(lock_info, int):
                    lock_pid = lock_info
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False
            except (ValueError, Exception):
                if content.isdigit():
                    lock_pid = int(content)
                else:
                    log.debug("Invalid lock file content", path=str(self.path), content=content[:50])
                    return False

            if lock_pid is None:
                log.debug("No PID in lock file", path=str(self.path))
                return False

            # Validate process with psutil for robust PID recycling protection
            try:
                proc = psutil.Process(lock_pid)

                # Call a method to trigger NoSuchProcess if PID doesn't exist
                # This is needed because Process.__init__ is lazy
                proc_start_time = proc.create_time()

                # If we have start_time, validate it matches to prevent PID recycling
                # Allow 1 second tolerance for timestamp precision differences
                if lock_start_time is not None and abs(proc_start_time - lock_start_time) > 1.0:
                    log.warning(
                        "PID recycling detected - removing stale lock",
                        path=str(self.path),
                        lock_pid=lock_pid,
                        lock_start=lock_start_time,
                        proc_start=proc_start_time,
                    )
                    try:
                        self.path.unlink()
                        return True
                    except FileNotFoundError:
                        return True
                    except (OSError, PermissionError):
                        # Failed to remove stale lock (permission denied, etc.)
                        return False

                # Process exists and start time matches (or no start time available)
                return False

            except psutil.NoSuchProcess:
                # Process doesn't exist - lock is stale
                log.warning("Removing stale lock - process not found", path=str(self.path), stale_pid=lock_pid)
                try:
                    self.path.unlink()
                    return True
                except FileNotFoundError:
                    return True
                except (OSError, PermissionError):
                    # Failed to remove stale lock (permission denied, etc.)
                    return False

            except psutil.AccessDenied:
                # Can't check process - assume it's valid to be safe
                return False

        except Exception as e:
            # Generic catch intentional: Safety net for security-critical lock validation.
            # Catches any unexpected errors (psutil errors, filesystem issues, etc.)
            # Fail-safe: return False to assume lock is valid rather than risk corruption.
            log.debug("Error checking stale lock", path=str(self.path), error=str(e))
            return False

        return True

    xǁFileLockǁ_check_stale_lock__mutmut_mutants: ClassVar[MutantDict] = {
        "xǁFileLockǁ_check_stale_lock__mutmut_1": xǁFileLockǁ_check_stale_lock__mutmut_1,
        "xǁFileLockǁ_check_stale_lock__mutmut_2": xǁFileLockǁ_check_stale_lock__mutmut_2,
        "xǁFileLockǁ_check_stale_lock__mutmut_3": xǁFileLockǁ_check_stale_lock__mutmut_3,
        "xǁFileLockǁ_check_stale_lock__mutmut_4": xǁFileLockǁ_check_stale_lock__mutmut_4,
        "xǁFileLockǁ_check_stale_lock__mutmut_5": xǁFileLockǁ_check_stale_lock__mutmut_5,
        "xǁFileLockǁ_check_stale_lock__mutmut_6": xǁFileLockǁ_check_stale_lock__mutmut_6,
        "xǁFileLockǁ_check_stale_lock__mutmut_7": xǁFileLockǁ_check_stale_lock__mutmut_7,
        "xǁFileLockǁ_check_stale_lock__mutmut_8": xǁFileLockǁ_check_stale_lock__mutmut_8,
        "xǁFileLockǁ_check_stale_lock__mutmut_9": xǁFileLockǁ_check_stale_lock__mutmut_9,
        "xǁFileLockǁ_check_stale_lock__mutmut_10": xǁFileLockǁ_check_stale_lock__mutmut_10,
        "xǁFileLockǁ_check_stale_lock__mutmut_11": xǁFileLockǁ_check_stale_lock__mutmut_11,
        "xǁFileLockǁ_check_stale_lock__mutmut_12": xǁFileLockǁ_check_stale_lock__mutmut_12,
        "xǁFileLockǁ_check_stale_lock__mutmut_13": xǁFileLockǁ_check_stale_lock__mutmut_13,
        "xǁFileLockǁ_check_stale_lock__mutmut_14": xǁFileLockǁ_check_stale_lock__mutmut_14,
        "xǁFileLockǁ_check_stale_lock__mutmut_15": xǁFileLockǁ_check_stale_lock__mutmut_15,
        "xǁFileLockǁ_check_stale_lock__mutmut_16": xǁFileLockǁ_check_stale_lock__mutmut_16,
        "xǁFileLockǁ_check_stale_lock__mutmut_17": xǁFileLockǁ_check_stale_lock__mutmut_17,
        "xǁFileLockǁ_check_stale_lock__mutmut_18": xǁFileLockǁ_check_stale_lock__mutmut_18,
        "xǁFileLockǁ_check_stale_lock__mutmut_19": xǁFileLockǁ_check_stale_lock__mutmut_19,
        "xǁFileLockǁ_check_stale_lock__mutmut_20": xǁFileLockǁ_check_stale_lock__mutmut_20,
        "xǁFileLockǁ_check_stale_lock__mutmut_21": xǁFileLockǁ_check_stale_lock__mutmut_21,
        "xǁFileLockǁ_check_stale_lock__mutmut_22": xǁFileLockǁ_check_stale_lock__mutmut_22,
        "xǁFileLockǁ_check_stale_lock__mutmut_23": xǁFileLockǁ_check_stale_lock__mutmut_23,
        "xǁFileLockǁ_check_stale_lock__mutmut_24": xǁFileLockǁ_check_stale_lock__mutmut_24,
        "xǁFileLockǁ_check_stale_lock__mutmut_25": xǁFileLockǁ_check_stale_lock__mutmut_25,
        "xǁFileLockǁ_check_stale_lock__mutmut_26": xǁFileLockǁ_check_stale_lock__mutmut_26,
        "xǁFileLockǁ_check_stale_lock__mutmut_27": xǁFileLockǁ_check_stale_lock__mutmut_27,
        "xǁFileLockǁ_check_stale_lock__mutmut_28": xǁFileLockǁ_check_stale_lock__mutmut_28,
        "xǁFileLockǁ_check_stale_lock__mutmut_29": xǁFileLockǁ_check_stale_lock__mutmut_29,
        "xǁFileLockǁ_check_stale_lock__mutmut_30": xǁFileLockǁ_check_stale_lock__mutmut_30,
        "xǁFileLockǁ_check_stale_lock__mutmut_31": xǁFileLockǁ_check_stale_lock__mutmut_31,
        "xǁFileLockǁ_check_stale_lock__mutmut_32": xǁFileLockǁ_check_stale_lock__mutmut_32,
        "xǁFileLockǁ_check_stale_lock__mutmut_33": xǁFileLockǁ_check_stale_lock__mutmut_33,
        "xǁFileLockǁ_check_stale_lock__mutmut_34": xǁFileLockǁ_check_stale_lock__mutmut_34,
        "xǁFileLockǁ_check_stale_lock__mutmut_35": xǁFileLockǁ_check_stale_lock__mutmut_35,
        "xǁFileLockǁ_check_stale_lock__mutmut_36": xǁFileLockǁ_check_stale_lock__mutmut_36,
        "xǁFileLockǁ_check_stale_lock__mutmut_37": xǁFileLockǁ_check_stale_lock__mutmut_37,
        "xǁFileLockǁ_check_stale_lock__mutmut_38": xǁFileLockǁ_check_stale_lock__mutmut_38,
        "xǁFileLockǁ_check_stale_lock__mutmut_39": xǁFileLockǁ_check_stale_lock__mutmut_39,
        "xǁFileLockǁ_check_stale_lock__mutmut_40": xǁFileLockǁ_check_stale_lock__mutmut_40,
        "xǁFileLockǁ_check_stale_lock__mutmut_41": xǁFileLockǁ_check_stale_lock__mutmut_41,
        "xǁFileLockǁ_check_stale_lock__mutmut_42": xǁFileLockǁ_check_stale_lock__mutmut_42,
        "xǁFileLockǁ_check_stale_lock__mutmut_43": xǁFileLockǁ_check_stale_lock__mutmut_43,
        "xǁFileLockǁ_check_stale_lock__mutmut_44": xǁFileLockǁ_check_stale_lock__mutmut_44,
        "xǁFileLockǁ_check_stale_lock__mutmut_45": xǁFileLockǁ_check_stale_lock__mutmut_45,
        "xǁFileLockǁ_check_stale_lock__mutmut_46": xǁFileLockǁ_check_stale_lock__mutmut_46,
        "xǁFileLockǁ_check_stale_lock__mutmut_47": xǁFileLockǁ_check_stale_lock__mutmut_47,
        "xǁFileLockǁ_check_stale_lock__mutmut_48": xǁFileLockǁ_check_stale_lock__mutmut_48,
        "xǁFileLockǁ_check_stale_lock__mutmut_49": xǁFileLockǁ_check_stale_lock__mutmut_49,
        "xǁFileLockǁ_check_stale_lock__mutmut_50": xǁFileLockǁ_check_stale_lock__mutmut_50,
        "xǁFileLockǁ_check_stale_lock__mutmut_51": xǁFileLockǁ_check_stale_lock__mutmut_51,
        "xǁFileLockǁ_check_stale_lock__mutmut_52": xǁFileLockǁ_check_stale_lock__mutmut_52,
        "xǁFileLockǁ_check_stale_lock__mutmut_53": xǁFileLockǁ_check_stale_lock__mutmut_53,
        "xǁFileLockǁ_check_stale_lock__mutmut_54": xǁFileLockǁ_check_stale_lock__mutmut_54,
        "xǁFileLockǁ_check_stale_lock__mutmut_55": xǁFileLockǁ_check_stale_lock__mutmut_55,
        "xǁFileLockǁ_check_stale_lock__mutmut_56": xǁFileLockǁ_check_stale_lock__mutmut_56,
        "xǁFileLockǁ_check_stale_lock__mutmut_57": xǁFileLockǁ_check_stale_lock__mutmut_57,
        "xǁFileLockǁ_check_stale_lock__mutmut_58": xǁFileLockǁ_check_stale_lock__mutmut_58,
        "xǁFileLockǁ_check_stale_lock__mutmut_59": xǁFileLockǁ_check_stale_lock__mutmut_59,
        "xǁFileLockǁ_check_stale_lock__mutmut_60": xǁFileLockǁ_check_stale_lock__mutmut_60,
        "xǁFileLockǁ_check_stale_lock__mutmut_61": xǁFileLockǁ_check_stale_lock__mutmut_61,
        "xǁFileLockǁ_check_stale_lock__mutmut_62": xǁFileLockǁ_check_stale_lock__mutmut_62,
        "xǁFileLockǁ_check_stale_lock__mutmut_63": xǁFileLockǁ_check_stale_lock__mutmut_63,
        "xǁFileLockǁ_check_stale_lock__mutmut_64": xǁFileLockǁ_check_stale_lock__mutmut_64,
        "xǁFileLockǁ_check_stale_lock__mutmut_65": xǁFileLockǁ_check_stale_lock__mutmut_65,
        "xǁFileLockǁ_check_stale_lock__mutmut_66": xǁFileLockǁ_check_stale_lock__mutmut_66,
        "xǁFileLockǁ_check_stale_lock__mutmut_67": xǁFileLockǁ_check_stale_lock__mutmut_67,
        "xǁFileLockǁ_check_stale_lock__mutmut_68": xǁFileLockǁ_check_stale_lock__mutmut_68,
        "xǁFileLockǁ_check_stale_lock__mutmut_69": xǁFileLockǁ_check_stale_lock__mutmut_69,
        "xǁFileLockǁ_check_stale_lock__mutmut_70": xǁFileLockǁ_check_stale_lock__mutmut_70,
        "xǁFileLockǁ_check_stale_lock__mutmut_71": xǁFileLockǁ_check_stale_lock__mutmut_71,
        "xǁFileLockǁ_check_stale_lock__mutmut_72": xǁFileLockǁ_check_stale_lock__mutmut_72,
        "xǁFileLockǁ_check_stale_lock__mutmut_73": xǁFileLockǁ_check_stale_lock__mutmut_73,
        "xǁFileLockǁ_check_stale_lock__mutmut_74": xǁFileLockǁ_check_stale_lock__mutmut_74,
        "xǁFileLockǁ_check_stale_lock__mutmut_75": xǁFileLockǁ_check_stale_lock__mutmut_75,
        "xǁFileLockǁ_check_stale_lock__mutmut_76": xǁFileLockǁ_check_stale_lock__mutmut_76,
        "xǁFileLockǁ_check_stale_lock__mutmut_77": xǁFileLockǁ_check_stale_lock__mutmut_77,
        "xǁFileLockǁ_check_stale_lock__mutmut_78": xǁFileLockǁ_check_stale_lock__mutmut_78,
        "xǁFileLockǁ_check_stale_lock__mutmut_79": xǁFileLockǁ_check_stale_lock__mutmut_79,
        "xǁFileLockǁ_check_stale_lock__mutmut_80": xǁFileLockǁ_check_stale_lock__mutmut_80,
        "xǁFileLockǁ_check_stale_lock__mutmut_81": xǁFileLockǁ_check_stale_lock__mutmut_81,
        "xǁFileLockǁ_check_stale_lock__mutmut_82": xǁFileLockǁ_check_stale_lock__mutmut_82,
        "xǁFileLockǁ_check_stale_lock__mutmut_83": xǁFileLockǁ_check_stale_lock__mutmut_83,
        "xǁFileLockǁ_check_stale_lock__mutmut_84": xǁFileLockǁ_check_stale_lock__mutmut_84,
        "xǁFileLockǁ_check_stale_lock__mutmut_85": xǁFileLockǁ_check_stale_lock__mutmut_85,
        "xǁFileLockǁ_check_stale_lock__mutmut_86": xǁFileLockǁ_check_stale_lock__mutmut_86,
        "xǁFileLockǁ_check_stale_lock__mutmut_87": xǁFileLockǁ_check_stale_lock__mutmut_87,
        "xǁFileLockǁ_check_stale_lock__mutmut_88": xǁFileLockǁ_check_stale_lock__mutmut_88,
        "xǁFileLockǁ_check_stale_lock__mutmut_89": xǁFileLockǁ_check_stale_lock__mutmut_89,
        "xǁFileLockǁ_check_stale_lock__mutmut_90": xǁFileLockǁ_check_stale_lock__mutmut_90,
        "xǁFileLockǁ_check_stale_lock__mutmut_91": xǁFileLockǁ_check_stale_lock__mutmut_91,
        "xǁFileLockǁ_check_stale_lock__mutmut_92": xǁFileLockǁ_check_stale_lock__mutmut_92,
        "xǁFileLockǁ_check_stale_lock__mutmut_93": xǁFileLockǁ_check_stale_lock__mutmut_93,
        "xǁFileLockǁ_check_stale_lock__mutmut_94": xǁFileLockǁ_check_stale_lock__mutmut_94,
        "xǁFileLockǁ_check_stale_lock__mutmut_95": xǁFileLockǁ_check_stale_lock__mutmut_95,
        "xǁFileLockǁ_check_stale_lock__mutmut_96": xǁFileLockǁ_check_stale_lock__mutmut_96,
        "xǁFileLockǁ_check_stale_lock__mutmut_97": xǁFileLockǁ_check_stale_lock__mutmut_97,
        "xǁFileLockǁ_check_stale_lock__mutmut_98": xǁFileLockǁ_check_stale_lock__mutmut_98,
        "xǁFileLockǁ_check_stale_lock__mutmut_99": xǁFileLockǁ_check_stale_lock__mutmut_99,
        "xǁFileLockǁ_check_stale_lock__mutmut_100": xǁFileLockǁ_check_stale_lock__mutmut_100,
        "xǁFileLockǁ_check_stale_lock__mutmut_101": xǁFileLockǁ_check_stale_lock__mutmut_101,
        "xǁFileLockǁ_check_stale_lock__mutmut_102": xǁFileLockǁ_check_stale_lock__mutmut_102,
        "xǁFileLockǁ_check_stale_lock__mutmut_103": xǁFileLockǁ_check_stale_lock__mutmut_103,
        "xǁFileLockǁ_check_stale_lock__mutmut_104": xǁFileLockǁ_check_stale_lock__mutmut_104,
        "xǁFileLockǁ_check_stale_lock__mutmut_105": xǁFileLockǁ_check_stale_lock__mutmut_105,
        "xǁFileLockǁ_check_stale_lock__mutmut_106": xǁFileLockǁ_check_stale_lock__mutmut_106,
        "xǁFileLockǁ_check_stale_lock__mutmut_107": xǁFileLockǁ_check_stale_lock__mutmut_107,
    }

    def _check_stale_lock(self, *args, **kwargs):
        result = _mutmut_trampoline(
            object.__getattribute__(self, "xǁFileLockǁ_check_stale_lock__mutmut_orig"),
            object.__getattribute__(self, "xǁFileLockǁ_check_stale_lock__mutmut_mutants"),
            args,
            kwargs,
            self,
        )
        return result

    _check_stale_lock.__signature__ = _mutmut_signature(xǁFileLockǁ_check_stale_lock__mutmut_orig)
    xǁFileLockǁ_check_stale_lock__mutmut_orig.__name__ = "xǁFileLockǁ_check_stale_lock"

    def __enter__(self) -> FileLock:
        """Context manager entry."""
        self.acquire()
        return self

    def __exit__(self, exc_type: object, exc_val: object, exc_tb: object) -> None:
        """Context manager exit."""
        self.release()


__all__ = [
    "FileLock",
    "LockError",
]


# <3 🧱🤝📄🪄
